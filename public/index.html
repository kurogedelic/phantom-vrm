<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Phantom-VRM Avatar</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      overflow: hidden;
    }
    #canvas { width: 100vw; height: 100vh; display: block; }
    
    /* „Çπ„ÉÜ„Éº„Çø„ÇπË°®Á§∫Ôºà„Éá„Éê„ÉÉ„Ç∞„É¢„Éº„ÉâÊôÇ„ÅÆ„Åø„ÄÅÂè≥‰∏ã„ÄÅ„ÉÜ„Ç≠„Çπ„ÉàÂÖ•Âäõ„ÅÆÂâçÔºâ */
    #status {
      position: fixed;
      bottom: 70px;
      right: 20px;
      color: #fff;
      font-family: sans-serif;
      font-size: 14px;
      opacity: 0.7;
      z-index: 100;
      display: none;
      transition: opacity 0.5s ease-out;
    }

    #status.fade-out {
      opacity: 0;
    }

    body.debug-mode #status {
      display: block;
    }

    /* „Éá„Éê„ÉÉ„Ç∞„Éë„Éç„É´ÔºàÂè≥‰∏ãÔºâ */
    #debug-panel {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: none;
      flex-direction: column;
      gap: 10px;
      z-index: 100;
    }

    body.debug-mode #debug-panel {
      display: flex;
    }
    
    #debug-panel input {
      padding: 10px 15px;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 8px;
      color: #fff;
      font-size: 14px;
      width: 250px;
      outline: none;
    }
    
    #debug-panel input:focus {
      border-color: rgba(100, 149, 237, 0.8);
    }
    
    #debug-panel input::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }

    /* „ÉÜ„É≠„ÉÉ„ÉóÔºàÂ≠óÂπïÔºâ„Ç®„É™„Ç¢ */
    #telop {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      max-width: 80%;
      padding: 15px 30px;
      background: rgba(0, 0, 0, 0.75);
      border-radius: 10px;
      color: #fff;
      font-family: 'Noto Sans JP', 'Hiragino Sans', 'Yu Gothic', sans-serif;
      font-size: 20px;
      text-align: center;
      line-height: 1.6;
      opacity: 0;
      transition: opacity 0.3s ease-in-out;
      z-index: 50;
      pointer-events: none;
    }

    #telop.visible {
      opacity: 1;
    }

    /* Ë°®ÊÉÖ„Éª„Éù„Éº„Ç∫„Éë„Éç„É´ÔºàÂè≥ÂÅ¥„ÄÅ„Çø„ÉñÂΩ¢ÂºèÔºâ */
    #control-panel {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 200px;
      background: rgba(20, 20, 40, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      padding: 16px;
      display: none;
      flex-direction: column;
      gap: 12px;
      z-index: 100;
      backdrop-filter: blur(10px);
    }

    body.debug-mode #control-panel {
      display: flex;
    }

    /* „Çø„Éñ */
    .control-tabs {
      display: flex;
      gap: 4px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      padding-bottom: 8px;
    }

    .control-tab {
      flex: 1;
      padding: 8px;
      background: transparent;
      border: none;
      color: rgba(255, 255, 255, 0.6);
      font-family: sans-serif;
      font-size: 13px;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.2s ease;
    }

    .control-tab:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .control-tab.active {
      background: rgba(100, 149, 237, 0.4);
      color: #fff;
    }

    /* „Çø„Éñ„Ç≥„É≥„ÉÜ„É≥„ÉÑ */
    .control-content {
      display: none;
      flex-direction: column;
      gap: 8px;
      padding-top: 8px;
    }

    .control-content.active {
      display: flex;
    }

    /* Ë°®ÊÉÖ„Éª„Éù„Éº„Ç∫„Éú„Çø„É≥ */
    #expression-controls, #pose-controls {
      display: contents;
    }

    .pose-btn, .expr-btn {
      padding: 10px 16px;
      background: rgba(255, 255, 255, 0.15);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 8px;
      color: #fff;
      font-family: 'Noto Sans JP', sans-serif;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s ease;
      backdrop-filter: blur(5px);
    }

    .pose-btn:hover, .expr-btn:hover {
      background: rgba(255, 255, 255, 0.25);
      border-color: rgba(255, 255, 255, 0.5);
    }

    .pose-btn:active, .expr-btn:active {
      transform: scale(0.95);
    }

    .pose-btn.active, .expr-btn.active {
      background: rgba(100, 149, 237, 0.5);
      border-color: rgba(100, 149, 237, 0.8);
    }

    .expr-btn.happy { border-left: 3px solid #ffeb3b; }
    .expr-btn.sad { border-left: 3px solid #2196f3; }
    .expr-btn.angry { border-left: 3px solid #f44336; }
    .expr-btn.relaxed { border-left: 3px solid #4caf50; }
    .expr-btn.surprised { border-left: 3px solid #ff9800; }
    .expr-btn.neutral { border-left: 3px solid #9e9e9e; }

    /* Ê≠ØËªä„Ç¢„Ç§„Ç≥„É≥Ôºà„Éá„Éê„ÉÉ„Ç∞„É¢„Éº„ÉâÊôÇ„ÅÆ„Åø„ÄÅÂ∑¶‰∏ãÔºâ */
    #settings-toggle {
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 44px;
      height: 44px;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 8px;
      cursor: pointer;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      z-index: 101;
      transition: background 0.2s, transform 0.2s;
    }

    body.debug-mode #settings-toggle {
      display: flex;
    }

    #settings-toggle:hover {
      background: rgba(100, 149, 237, 0.5);
      transform: scale(1.05);
    }

    /* Ë®≠ÂÆö„Éë„Éç„É´ÔºàÂ∑¶‰∏ãÔºâ */
    #settings-panel {
      position: fixed;
      bottom: 74px;
      left: 20px;
      width: 320px;
      max-height: calc(100vh - 100px);
      background: rgba(20, 20, 40, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      padding: 20px;
      display: none;
      flex-direction: column;
      gap: 16px;
      z-index: 100;
      overflow-y: auto;
      backdrop-filter: blur(10px);
    }

    #settings-panel.visible {
      display: flex;
    }

    #settings-panel h3 {
      color: #fff;
      font-family: 'Noto Sans JP', sans-serif;
      font-size: 16px;
      margin: 0;
      padding-bottom: 10px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    }

    .settings-group {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .settings-group label {
      color: rgba(255, 255, 255, 0.8);
      font-family: sans-serif;
      font-size: 13px;
      font-weight: 500;
    }

    .settings-group input[type="range"] {
      width: 100%;
      height: 6px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 3px;
      outline: none;
      -webkit-appearance: none;
    }

    .settings-group input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: #6495ed;
      border-radius: 50%;
      cursor: pointer;
    }

    .settings-group input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: #6495ed;
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }

    .settings-group select {
      width: 100%;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 6px;
      color: #fff;
      font-family: sans-serif;
      font-size: 13px;
      outline: none;
      cursor: pointer;
    }

    .settings-group select:focus {
      border-color: rgba(100, 149, 237, 0.8);
    }

    .settings-row {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .settings-row label {
      flex: 1;
      min-width: 80px;
    }

    .settings-row input[type="range"] {
      flex: 2;
    }

    .settings-value {
      color: rgba(255, 255, 255, 0.6);
      font-family: sans-serif;
      font-size: 12px;
      min-width: 40px;
      text-align: right;
    }

    /* ==================== „ÇØ„É™„Ç®„Ç§„Ç∑„Éß„É≥„É¢„Éº„Éâ ==================== */
    body.creation-mode {
      cursor: crosshair;
    }

    #creation-panel {
      position: fixed;
      top: 20px;
      left: 20px;
      width: 320px;
      max-height: calc(100vh - 40px);
      background: rgba(0, 0, 0, 0.85);
      border-radius: 12px;
      padding: 20px;
      display: none;
      flex-direction: column;
      gap: 15px;
      overflow-y: auto;
      z-index: 200;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    body.creation-mode #creation-panel {
      display: flex;
    }

    #creation-panel h3 {
      color: #fff;
      margin: 0;
      font-size: 16px;
      font-weight: 600;
      padding-bottom: 10px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    }

    .creation-tabs {
      display: flex;
      gap: 5px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .creation-tab {
      flex: 1;
      padding: 10px;
      background: rgba(255, 255, 255, 0.05);
      border: none;
      color: rgba(255, 255, 255, 0.6);
      cursor: pointer;
      border-radius: 6px 6px 0 0;
      transition: all 0.2s;
      font-size: 13px;
    }

    .creation-tab.active {
      background: rgba(100, 149, 237, 0.3);
      color: #fff;
    }

    .creation-tab:hover {
      background: rgba(100, 149, 237, 0.2);
    }

    .creation-content {
      display: none;
      flex-direction: column;
      gap: 12px;
      padding: 10px 0;
    }

    .creation-content.active {
      display: flex;
    }

    .expression-sliders {
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-height: 400px;
      overflow-y: auto;
      padding-right: 5px;
    }

    .expression-sliders::-webkit-scrollbar {
      width: 6px;
    }

    .expression-sliders::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 3px;
    }

    .expression-sliders::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 3px;
    }

    .expression-slider {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .expression-slider label {
      color: rgba(255, 255, 255, 0.8);
      font-size: 12px;
      font-family: sans-serif;
      display: flex;
      justify-content: space-between;
    }

    .expression-slider input[type="range"] {
      width: 100%;
      height: 4px;
      -webkit-appearance: none;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px;
      outline: none;
    }

    .expression-slider input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: #6495ed;
      border-radius: 50%;
      cursor: pointer;
    }

    .preset-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 200px;
      overflow-y: auto;
    }

    .preset-item {
      display: flex;
      gap: 8px;
      padding: 8px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 6px;
      align-items: center;
    }

    .preset-name {
      flex: 1;
      color: rgba(255, 255, 255, 0.8);
      font-size: 13px;
      font-family: sans-serif;
    }

    .preset-actions {
      display: flex;
      gap: 5px;
    }

    .preset-actions button {
      padding: 4px 8px;
      background: rgba(255, 255, 255, 0.1);
      border: none;
      color: #fff;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      transition: background 0.2s;
    }

    .preset-actions button:hover {
      background: rgba(255, 100, 100, 0.3);
    }

    .btn {
      padding: 10px 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.2s;
      font-family: sans-serif;
    }

    .btn-primary {
      background: #6495ed;
      color: #fff;
    }

    .btn-primary:hover {
      background: #5a82d3;
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
    }

    .btn-secondary:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .btn-group {
      display: flex;
      gap: 8px;
    }

    .btn-group .btn {
      flex: 1;
    }

    .input-group {
      display: flex;
      gap: 8px;
    }

    .input-group input {
      flex: 1;
      padding: 8px 12px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      color: #fff;
      font-size: 13px;
      outline: none;
    }

    .input-group input:focus {
      border-color: #6495ed;
    }

    .input-group input::placeholder {
      color: rgba(255, 255, 255, 0.4);
    }

    .pose-controls {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .bone-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 300px;
      overflow-y: auto;
    }

    .bone-item {
      padding: 10px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
    }

    .bone-item:hover {
      background: rgba(100, 149, 237, 0.2);
    }

    .bone-item.selected {
      background: rgba(100, 149, 237, 0.3);
      border: 1px solid rgba(100, 149, 237, 0.5);
    }

    .bone-name {
      color: #fff;
      font-size: 13px;
      font-family: sans-serif;
    }

    .rotation-controls {
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 15px;
      background: rgba(255, 255, 255, 0.03);
      border-radius: 8px;
    }

    .rotation-control {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .rotation-control label {
      color: rgba(255, 255, 255, 0.7);
      font-size: 12px;
      width: 20px;
      font-family: sans-serif;
    }

    .rotation-control input[type="range"] {
      flex: 1;
    }

    .rotation-value {
      color: rgba(255, 255, 255, 0.6);
      font-size: 11px;
      font-family: monospace;
      width: 50px;
      text-align: right;
    }

    /* „Ç®„ÇØ„Çπ„Éù„Éº„Éà/„Ç§„É≥„Éù„Éº„Éà„É¢„Éº„ÉÄ„É´ */
    #export-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    #export-modal.active {
      display: flex;
    }

    .modal-content {
      background: rgba(30, 30, 40, 0.95);
      border-radius: 12px;
      padding: 25px;
      width: 500px;
      max-width: 90vw;
      max-height: 80vh;
      overflow-y: auto;
    }

    .modal-content h3 {
      color: #fff;
      margin: 0 0 15px 0;
      font-size: 18px;
    }

    .modal-content textarea {
      width: 100%;
      height: 300px;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      color: #fff;
      padding: 15px;
      font-family: monospace;
      font-size: 12px;
      resize: none;
    }

    .modal-actions {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="status">Loading...</div>

  <!-- Ê≠ØËªä„Ç¢„Ç§„Ç≥„É≥Ôºà„Éá„Éê„ÉÉ„Ç∞„É¢„Éº„ÉâÊôÇ„ÅÆ„ÅøË°®Á§∫Ôºâ -->
  <div id="settings-toggle" title="Settings">‚öôÔ∏è</div>

  <!-- Ë®≠ÂÆö„Éë„Éç„É´Ôºà„Éá„Éê„ÉÉ„Ç∞„É¢„Éº„ÉâÊôÇ„ÅÆ„ÅøË°®Á§∫Ôºâ -->
  <div id="settings-panel">
    <h3>Camera Settings</h3>
    <div class="settings-group">
      <div class="settings-row">
        <label>Distance</label>
        <input type="range" id="camera-distance" min="1" max="5" step="0.1" value="2.5">
        <span class="settings-value" id="camera-distance-value">2.5</span>
      </div>
      <div class="settings-row">
        <label>Height</label>
        <input type="range" id="camera-height" min="0" max="3" step="0.1" value="1.3">
        <span class="settings-value" id="camera-height-value">1.3</span>
      </div>
      <div class="settings-row">
        <label>Angle X</label>
        <input type="range" id="camera-angle-x" min="-1" max="1" step="0.05" value="0">
        <span class="settings-value" id="camera-angle-x-value">0</span>
      </div>
      <div class="settings-row">
        <label>FOV</label>
        <input type="range" id="camera-fov" min="20" max="60" step="1" value="30">
        <span class="settings-value" id="camera-fov-value">30</span>
      </div>
    </div>

    <h3>Background</h3>
    <div class="settings-group">
      <label>Preset</label>
      <select id="bg-preset">
        <option value="default">Default (Gradient)</option>
        <option value="black">Black</option>
        <option value="green">Green Screen</option>
        <option value="blue">Blue Screen</option>
        <option value="white">White</option>
        <option value="transparent">Transparent</option>
      </select>
    </div>

    <h3>Lighting</h3>
    <div class="settings-group">
      <div class="settings-row">
        <label>Main Light</label>
        <input type="range" id="light-main" min="0" max="2" step="0.1" value="1">
        <span class="settings-value" id="light-main-value">1.0</span>
      </div>
      <div class="settings-row">
        <label>Ambient</label>
        <input type="range" id="light-ambient" min="0" max="2" step="0.1" value="0.6">
        <span class="settings-value" id="light-ambient-value">0.6</span>
      </div>
    </div>
  </div>

  <!-- „Éá„Éê„ÉÉ„Ç∞„Éë„Éç„É´ÔºàÂè≥‰∏ã„ÄÅ?debug „ÅßË°®Á§∫Ôºâ -->
  <div id="debug-panel">
    <input type="text" id="speak-input" placeholder="Ë©±„Åï„Åõ„ÇãÂÜÖÂÆπ„ÇíÂÖ•Âäõ..." />
  </div>

  <!-- „ÉÜ„É≠„ÉÉ„ÉóÔºàÂ≠óÂπïÔºâ„Ç®„É™„Ç¢ -->
  <div id="telop"></div>

  <!-- Âà∂Âæ°„Éë„Éç„É´ÔºàEmotion„ÉªVRMA„ÄÅ„Çø„ÉñÂΩ¢ÂºèÔºâ -->
  <div id="control-panel">
    <div class="control-tabs">
      <button class="control-tab active" data-tab="emotions">Emotion</button>
      <button class="control-tab" data-tab="vrmas">VRMA</button>
    </div>
    <div id="emotions-content" class="control-content active">
      <!-- Ë°®ÊÉÖ„Éú„Çø„É≥ÔºàÂãïÁöÑÁîüÊàêÔºâ -->
      <div id="expression-controls">
        <!-- Buttons will be generated dynamically from config -->
      </div>
    </div>
    <div id="vrmas-content" class="control-content">
      <!-- VRMA„Éú„Çø„É≥ÔºàÂãïÁöÑÁîüÊàê„ÄÅË™≠„ÅøËæº„ÇÅ„Åü„ÇÇ„ÅÆ„ÅÆ„ÅøÔºâ -->
      <div id="pose-controls">
        <!-- Buttons will be generated dynamically from loaded VRMAs -->
      </div>
    </div>
  </div>

  <!-- „ÇØ„É™„Ç®„Ç§„Ç∑„Éß„É≥„É¢„Éº„Éâ„Éë„Éç„É´ -->
  <div id="creation-panel">
    <h3>üé® Creation Mode</h3>

    <div class="creation-tabs">
      <button class="creation-tab active" data-tab="expression">Expression</button>
      <button class="creation-tab" data-tab="pose">Pose</button>
    </div>

    <!-- Expression Creator -->
    <div id="expression-content" class="creation-content active">
      <div class="expression-sliders" id="expression-sliders">
        <!-- Sliders will be generated dynamically -->
      </div>

      <div class="input-group">
        <input type="text" id="new-expression-name" placeholder="Preset name...">
        <button class="btn btn-primary" id="save-expression-btn">Save</button>
      </div>

      <div class="preset-list" id="expression-presets">
        <!-- Custom presets will be listed here -->
      </div>

      <div class="btn-group">
        <button class="btn btn-secondary" id="export-expressions-btn">Export All</button>
        <button class="btn btn-secondary" id="import-expressions-btn">Import</button>
      </div>
    </div>

    <!-- Pose Creator -->
    <div id="pose-content" class="creation-content">
      <div class="pose-controls">
        <div class="bone-list" id="bone-list">
          <!-- Bones will be listed here -->
        </div>

        <div class="rotation-controls" id="rotation-controls" style="display: none;">
          <h4 style="color: #fff; margin: 0 0 10px 0; font-size: 14px;" id="selected-bone-name">Select a bone</h4>

          <div class="rotation-control">
            <label>X</label>
            <input type="range" id="rotation-x" min="-180" max="180" value="0">
            <span class="rotation-value" id="rotation-x-value">0¬∞</span>
          </div>

          <div class="rotation-control">
            <label>Y</label>
            <input type="range" id="rotation-y" min="-180" max="180" value="0">
            <span class="rotation-value" id="rotation-y-value">0¬∞</span>
          </div>

          <div class="rotation-control">
            <label>Z</label>
            <input type="range" id="rotation-z" min="-180" max="180" value="0">
            <span class="rotation-value" id="rotation-z-value">0¬∞</span>
          </div>

          <div class="btn-group">
            <button class="btn btn-secondary" id="reset-bone-btn">Reset Bone</button>
            <button class="btn btn-secondary" id="reset-all-bones-btn">Reset All</button>
          </div>
        </div>

        <div class="input-group">
          <input type="text" id="new-pose-name" placeholder="Pose name...">
          <button class="btn btn-primary" id="save-pose-btn">Save Pose</button>
        </div>

        <div class="preset-list" id="pose-presets">
          <!-- Custom poses will be listed here -->
        </div>

        <div class="btn-group">
          <button class="btn btn-secondary" id="export-poses-btn">Export All</button>
          <button class="btn btn-secondary" id="import-poses-btn">Import</button>
        </div>
      </div>
    </div>
  </div>

  <!-- „Ç®„ÇØ„Çπ„Éù„Éº„Éà/„Ç§„É≥„Éù„Éº„Éà„É¢„Éº„ÉÄ„É´ -->
  <div id="export-modal">
    <div class="modal-content">
      <h3 id="modal-title">Export</h3>
      <textarea id="modal-textarea" readonly></textarea>
      <div class="modal-actions">
        <button class="btn btn-primary" id="modal-copy-btn">Copy to Clipboard</button>
        <button class="btn btn-secondary" id="modal-close-btn">Close</button>
      </div>
    </div>
  </div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.167.1/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.167.1/examples/jsm/",
      "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3/lib/three-vrm.module.min.js",
      "@pixiv/three-vrm-animation": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm-animation@3/lib/three-vrm-animation.module.min.js"
    }
  }
  </script>
  
  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { VRMLoaderPlugin, VRMExpression } from '@pixiv/three-vrm';
    import { VRMAnimationLoaderPlugin, VRMAnimation, createVRMAnimationClip } from '@pixiv/three-vrm-animation';
    
    // „Éá„Éê„ÉÉ„Ç∞„É¢„Éº„ÉâÂà§ÂÆö
    const isDebugMode = new URLSearchParams(window.location.search).has('debug');
    if (isDebugMode) {
      document.body.classList.add('debug-mode');
      console.log('üêõ Debug mode enabled');
    }

    // „ÇØ„É™„Ç®„Ç§„Ç∑„Éß„É≥„É¢„Éº„ÉâÂà§ÂÆö
    const isCreationMode = new URLSearchParams(window.location.search).has('creation');
    if (isCreationMode) {
      document.body.classList.add('creation-mode');
      console.log('üé® Creation mode enabled');
    }

    // „Ç¢„Ç§„Éâ„É´„Éù„Éº„Ç∫Ë®≠ÂÆöÔºàJSONÂΩ¢ÂºèÔºâ
    const IDLE_POSE_CONFIG = {
      "name": "Natural Standing (Arms Down)",
      "description": "Ëá™ÁÑ∂„Å™Á´ã„Å°Âßø - T„Éù„Éº„Ç∫„Åã„ÇâËÖï„Çí‰∏ã„Çç„Åó„ÅüÁä∂ÊÖã",
      "bones": {
        "leftUpperArm": {
          "rotation": { "z": -1.4, "x": 0.1 },
          "animation": { "z": { "amplitude": 0.01, "frequency": 0.5, "offset": -1.4 } }
        },
        "rightUpperArm": {
          "rotation": { "z": 1.4, "x": 0.1 },
          "animation": { "z": { "amplitude": 0.01, "frequency": 0.5, "offset": 1.4 } }
        },
        "leftLowerArm": { "rotation": { "x": 0.0 } },
        "rightLowerArm": { "rotation": { "x": 0.0 } },
        "leftShoulder": { "rotation": { "z": 0.0 } },
        "rightShoulder": { "rotation": { "z": 0.0 } },
        "spine": { "animation": { "z": { "amplitude": 0.01, "frequency": 0.3 } } },
        "chest": { "animation": { "x": { "amplitude": 0.015, "frequency": 0.8, "type": "breath" } } },
        "upperChest": { "animation": { "x": { "amplitude": 0.0225, "frequency": 0.8, "type": "breath" } } },
        "neck": { "animation": { "z": { "type": "headTilt", "randomInterval": true } } },
        "head": { "animation": { "y": { "amplitude": 0.02, "frequency": 0.2 } } }
      },
      "expressions": {
        "blink": { "interval": { "min": 3, "max": 7 }, "duration": 0.15 }
      }
    };

    // „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞
    let scene, camera, renderer, vrm, clock;
    let ambientLight, directionalLight, backLight;
    let currentExpression = 'neutral';
    let mouthOpenness = 0;
    let targetMouthOpenness = 0;
    let currentPose = 'standing';

    // „Ç´„É°„É©„ÉªËÉåÊôØË®≠ÂÆö
    const cameraSettings = {
      distance: 2.5,
      height: 1.3,
      angleX: 0,
      fov: 30
    };

    const backgroundPresets = {
      default: 'linear-gradient(135deg, #1a1a2e 0%, #16213e 100%)',
      black: '#000000',
      green: '#00ff00',
      blue: '#0000ff',
      white: '#ffffff',
      transparent: 'transparent'
    };

    // VRMA„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÁÆ°ÁêÜ
    let loadedVRMAs = {};  // Ë™≠„ÅøËæº„ÅøÊ∏à„ÅøVRMA
    let currentVRMA = null;  // ÁèæÂú®ÂÜçÁîü‰∏≠„ÅÆVRMA
    let vrmaMixer = null;  // AnimationMixer

    // „ÇØ„É™„Ç®„Ç§„Ç∑„Éß„É≥„É¢„Éº„ÉâÁî®Â§âÊï∞
    let customExpressions = {};  // „Ç´„Çπ„Çø„É†Ë°®ÊÉÖ„Éó„É™„Çª„ÉÉ„Éà
    let customPoses = {};  // „Ç´„Çπ„Çø„É†„Éù„Éº„Ç∫„Éó„É™„Çª„ÉÉ„Éà
    let selectedBone = null;  // ÈÅ∏Êäû‰∏≠„ÅÆ„Éú„Éº„É≥
    let boneRotations = {};  // „Éú„Éº„É≥„ÅÆÂõûËª¢ÂÄ§„Çí‰øùÂ≠ò

    // Ë®≠ÂÆöÔºà„Çµ„Éº„Éê„Éº„Åã„Çâ„É≠„Éº„ÉâÔºâ
    let serverConfig = {
      expressions: [],
      vrma: {}
    };

    // VRMA„É¢„Éº„Ç∑„Éß„É≥ÂÆöÁæ©Ôºà„Çµ„Éº„Éê„ÉºË®≠ÂÆö„Åã„Çâ„É≠„Éº„ÉâÔºâ
    let vrmaMotions = {
      standing: { file: null, name: 'Á´ã„Å°ÂßøÔºà„Éá„Éï„Ç©„É´„ÉàÔºâ' }
    };

    // ÁèæÂú®„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„Çí‰øùÊåÅÔºà„ÇØ„É≠„Çπ„Éï„Çß„Éº„ÉâÁî®Ôºâ
    let currentAction = null;
    
    // „Ç¢„Ç§„Éâ„É´„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Áä∂ÊÖã
    const idleState = {
      blinkTimer: 0,
      nextBlink: 3 + Math.random() * 4,
      isBlinking: false,
      blinkDuration: 0.15,
      breathPhase: 0,
      swayPhase: 0,
      headTilt: 0,
      targetHeadTilt: 0,
      eyeLookAround: { x: 0, y: 0, targetX: 0, targetY: 0 }
    };
    
    // Áô∫Ë©±Áä∂ÊÖã
    let isSpeaking = false;
    let speakEndTime = 0;
    
    // Web Audio APIÔºà„É™„ÉÉ„Éó„Ç∑„É≥„ÇØÁî®Ôºâ
    let audioContext = null;
    let analyser = null;
    let currentAudio = null;
    let audioContextUnlocked = false;
    let audioSourceMap = new WeakMap(); // Èü≥Â£∞„ÇΩ„Éº„Çπ„ÅÆ„Éû„ÉÉ„ÉóÔºàÈáçË§áÊé•Á∂öÈò≤Ê≠¢Ôºâ
    
    // ==================== ÂàùÊúüÂåñ ====================
    async function init() {
      const status = document.getElementById('status');
      status.textContent = 'ÂàùÊúüÂåñ‰∏≠...';

      // AudioContextÂàùÊúüÂåñ
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        analyser.smoothingTimeConstant = 0.7;
        
        // Ëá™Âãï„ÅßÊúâÂäπÂåñ„ÇíË©¶„Åø„Çã
        if (audioContext.state === 'suspended') {
          audioContext.resume().then(() => {
            audioContextUnlocked = true;
            console.log('üîä AudioContextËá™ÂãïÊúâÂäπÂåñÊàêÂäü');
          }).catch(e => {
            console.warn('AudioContextËá™ÂãïÊúâÂäπÂåñÂ§±ÊïóÔºà„É¶„Éº„Ç∂„ÉºÊìç‰ΩúÂæÖ„Å°Ôºâ:', e);
          });
        } else {
          audioContextUnlocked = true;
          console.log('üîä AudioContextÂàùÊúüÂåñÂÆå‰∫Ü (state:', audioContext.state, ')');
        }
      } catch (e) {
        console.warn('Web Audio API not available:', e);
      }
      
      // „Ç∑„Éº„É≥
      scene = new THREE.Scene();
      
      // „Ç´„É°„É©
      camera = new THREE.PerspectiveCamera(cameraSettings.fov, window.innerWidth / window.innerHeight, 0.1, 20);
      camera.position.set(0, cameraSettings.height, cameraSettings.distance);
      camera.lookAt(0, cameraSettings.height, 0);

      // „É¨„É≥„ÉÄ„É©„Éº
      const canvas = document.getElementById('canvas');
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.outputColorSpace = THREE.SRGBColorSpace;

      // „É©„Ç§„ÉàÔºà„Ç∞„É≠„Éº„Éê„É´Â§âÊï∞„Å´‰øùÂ≠òÔºâ
      ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(1, 1, 1);
      scene.add(directionalLight);

      // ËÉåÈù¢„É©„Ç§„ÉàÔºàËº™ÈÉ≠Âº∑Ë™øÔºâ
      backLight = new THREE.DirectionalLight(0x8888ff, 0.3);
      backLight.position.set(-1, 1, -1);
      scene.add(backLight);
      
      // ÊôÇÈñì
      clock = new THREE.Clock();
      
      // VRMË™≠„ÅøËæº„Åø
      status.textContent = 'VRM„É¢„Éá„É´Ë™≠„ÅøËæº„Åø‰∏≠...';
      try {
        // Ë®≠ÂÆö„ÇíÂèñÂæó
        const configResponse = await fetch('/api/config');
        const config = await configResponse.json();
        serverConfig = config; // Ë®≠ÂÆö„Çí‰øùÂ≠ò
        const modelUrl = config.model || '/models/your-avatar.vrm';

        await loadVRM(modelUrl);
        status.textContent = '„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Ë™≠„ÅøËæº„Åø‰∏≠...';

        // Ë®≠ÂÆö„Åã„ÇâVRMA„É¢„Éº„Ç∑„Éß„É≥„Çí„Çª„ÉÉ„ÉàÔºàÂÖà„Å´Ë®≠ÂÆöÔºÅÔºâ
        const configVrma = config.vrma || {};
        for (const [key, filePath] of Object.entries(configVrma)) {
          // „Éï„Ç°„Ç§„É´Âêç„ÇíÊäΩÂá∫Ôºà„Éë„Çπ„Åã„ÇâÊúÄÂæå„ÅÆÈÉ®ÂàÜÔºâ
          const fileName = filePath.split('/').pop().split('\\').pop();
          vrmaMotions[key] = { file: fileName, name: key };
        }

        // VRMA„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Ë™≠„ÅøËæº„ÅøÔºàË®≠ÂÆöÂæåÔºâ
        await loadVRMAs();

        // „Éá„Éê„ÉÉ„Ç∞Áî®: VRMA„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÊßãÈÄ†Á¢∫Ë™ç
        window.debugVRMA = loadedVRMAs;
        const firstVRMA = Object.entries(loadedVRMAs)[0];
        if (firstVRMA) {
          console.log('üßê VRMA Object Structure:', firstVRMA[1]);
          console.log('üßê VRMA Methods:', Object.getOwnPropertyNames(Object.getPrototypeOf(firstVRMA[1])));
          console.log('üßê VRMAnimation static:', Object.getOwnPropertyNames(VRMAnimation));
        }

        // „ÇØ„É™„Ç®„Ç§„Ç∑„Éß„É≥„É¢„Éº„ÉâÂàùÊúüÂåñ
        if (isCreationMode) {
          initCreationMode();
        }

        status.textContent = '„Ç¢„Éê„Çø„ÉºÊ∫ñÂÇôÂÆå‰∫Ü!';
        // 1ÁßíÂæå„Å´„Çπ„ÉÜ„Éº„Çø„Çπ„ÇíÊ∂à„Åô
        setTimeout(() => {
          if (status) status.classList.add('fade-out');
          setTimeout(() => {
            if (status) status.style.display = 'none';
          }, 500);
        }, 1000);
      } catch (error) {
        status.textContent = '„Ç®„É©„Éº: ' + error.message;
        console.error('VRMË™≠„ÅøËæº„Åø„Ç®„É©„Éº:', error);
        return;
      }

      // AnimationMixer‰ΩúÊàê
      vrmaMixer = new THREE.AnimationMixer(vrm.scene);

      // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÈñãÂßã
      animate();
      
      // APIÂæÖÂèóÈñãÂßã
      startMessagePolling();

      // „Éá„Éê„ÉÉ„Ç∞„Éë„Éç„É´„ÇíÂãïÁöÑ„Å´ÁîüÊàê
      if (isDebugMode) {
        generateDebugPanel();
        initSettingsPanel();
      }
    }
    
    // ==================== VRMË™≠„ÅøËæº„Åø ====================
    async function loadVRM(url) {
      const loader = new GLTFLoader();
      loader.register((parser) => new VRMLoaderPlugin(parser));

      return new Promise((resolve, reject) => {
        loader.load(
          url,
          (gltf) => {
            vrm = gltf.userData.vrm;
            scene.add(vrm.scene);
            console.log('‚úÖ VRMË™≠„ÅøËæº„ÅøÂÆå‰∫Ü:', vrm);

            // „Éá„Éê„ÉÉ„Ç∞: Âà©Áî®ÂèØËÉΩ„Å™Ë°®ÊÉÖ„ÇíË°®Á§∫ (v3ÂØæÂøú)
            if (vrm.expressionManager) {
              const exprNames = vrm.expressionManager.expressions?.map(e => e.expressionName) || [];
              console.log('üìã Âà©Áî®ÂèØËÉΩ„Å™Ë°®ÊÉÖ:', exprNames);
            }

            resolve(vrm);
          },
          (progress) => {
            const percent = progress.total ? (progress.loaded / progress.total * 100).toFixed(1) : '...';
            console.log(`Ë™≠„ÅøËæº„Åø‰∏≠: ${percent}%`);
          },
          (error) => {
            console.error('VRMË™≠„ÅøËæº„Åø„Ç®„É©„Éº:', error);
            reject(error);
          }
        );
      });
    }

    // ==================== VRMAË™≠„ÅøËæº„Åø ====================
    async function loadVRMAs() {
      const loader = new GLTFLoader();
      loader.register((parser) => new VRMAnimationLoaderPlugin(parser));

      const loadPromises = [];

      for (const [key, motion] of Object.entries(vrmaMotions)) {
        if (!motion.file) continue;

        const promise = new Promise((resolve) => {
          const url = `/vrma/${motion.file}`;
          loader.load(
            url,
            (gltf) => {
              console.log(`üîç VRMA„É≠„Éº„ÉâÁµêÊûú [${motion.name}]:`, {
                userData: Object.keys(gltf.userData),
                vrmAnimation: gltf.userData.vrmAnimation,
                animations: gltf.animations?.length
              });
              
              // v3„Åß„ÅØ vrmAnimations (Ë§áÊï∞ÂΩ¢) „Åã„ÇâÂèñÂæó
              const vrma = gltf.userData.vrmAnimation 
                || gltf.userData.vrmAnimations?.[0]
                || gltf.userData.vrmAnim;
              
              if (vrma) {
                loadedVRMAs[key] = vrma;
                console.log(`‚úÖ VRMAË™≠„ÅøËæº„ÅøÂÆå‰∫Ü: ${motion.name}`);
              } else {
                console.warn(`‚ö†Ô∏è VRMA„Éá„Éº„Çø„Å™„Åó: ${motion.file}`, gltf.userData);
              }
              resolve();
            },
            (progress) => {
              // Ë™≠„ÅøËæº„ÅøÈÄ≤Êçó
            },
            (error) => {
              console.warn(`‚ö†Ô∏è VRMAË™≠„ÅøËæº„ÅøÂ§±Êïó: ${motion.file}`, error?.message || error);
              resolve();
            }
          );
        });

        loadPromises.push(promise);
      }

      await Promise.all(loadPromises);
      console.log(`üìã Ë™≠„ÅøËæº„ÅøÊ∏à„ÅøVRMA: ${Object.keys(loadedVRMAs).join(', ') || '„Å™„Åó'}`);

      // VRMA„Éú„Çø„É≥„ÇíÊõ¥Êñ∞ÔºàË™≠„ÅøËæº„Çì„Å†„ÇÇ„ÅÆ„ÅÆ„ÅøË°®Á§∫Ôºâ
      if (window.refreshVRMAButtons) {
        window.refreshVRMAButtons();
      }
    }

    // ==================== VRMAÂÜçÁîüÔºà„Çπ„É†„Éº„Ç∫„Éà„É©„É≥„Ç∏„Ç∑„Éß„É≥‰ªò„ÅçÔºâ====================
    function playVRMA(motionKey, loop = false, duration = 0.5) {
      if (!vrm) {
        console.warn('VRM„ÅåË™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì');
        return;
      }

      // standing„ÅÆÂ†¥Âêà„ÅØ„Ç¢„Ç§„Éâ„É´„Éù„Éº„Ç∫ÔºàËá™ÁÑ∂„Å™Á´ã„Å°ÂßøÔºâ„Å´Êàª„Åô
      if (motionKey === 'standing') {
        // VRMA„ÇíÂÅúÊ≠¢„Åó„Å¶„Ç¢„Ç§„Éâ„É´„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„Å´Êàª„Çã
        if (vrmaMixer) {
          if (currentAction) {
            currentAction.fadeOut(duration);
            currentAction = null;
          }
        }
        currentVRMA = null;
        currentPose = 'standing';
        updatePoseButtons('standing');
        console.log('üßç „Ç¢„Ç§„Éâ„É´„Éù„Éº„Ç∫„Å´Êàª„Çã');
        return;
      }

      if (!loadedVRMAs[motionKey]) {
        console.warn('VRMA„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì:', motionKey, 'Ë™≠„ÅøËæº„ÅøÊ∏à„Åø:', Object.keys(loadedVRMAs));
        return;
      }

      const vrma = loadedVRMAs[motionKey];
      console.log('üé¨ VRMAÂÜçÁîüË©¶Ë°å:', motionKey);

      // AnimationMixer„Åå„Å™„Åë„Çå„Å∞‰ΩúÊàê
      if (!vrmaMixer) {
        vrmaMixer = new THREE.AnimationMixer(vrm.scene);
      }

      // v3„ÅÆÊ≠£„Åó„ÅÑAPI: createVRMAnimationClip(vrma, vrm)
      const clip = createVRMAnimationClip(vrma, vrm);

      if (!clip) {
        console.error('AnimationClip‰ΩúÊàêÂ§±Êïó:', motionKey);
        return;
      }

      const newAction = vrmaMixer.clipAction(clip);
      newAction.setLoop(loop ? THREE.LoopRepeat : THREE.LoopOnce);
      newAction.clampWhenFinished = true;
      newAction.reset();

      // „ÇØ„É≠„Çπ„Éï„Çß„Éº„Éâ: Ââç„ÅÆ„Ç¢„ÇØ„Ç∑„Éß„É≥„Åã„ÇâÊªë„Çâ„Åã„Å´ÁßªË°å
      if (currentAction) {
        newAction.crossFadeFrom(currentAction, duration, true);
      }
      
      newAction.play();
      currentAction = newAction;

      currentVRMA = motionKey;
      currentPose = motionKey;

      console.log('üé¨ VRMAÂÜçÁîüÈñãÂßã:', vrmaMotions[motionKey]?.name || motionKey, '(loop:', loop, ')');

      // „Éú„Çø„É≥„ÅÆ„Ç¢„ÇØ„ÉÜ„Ç£„ÉñÁä∂ÊÖãÊõ¥Êñ∞
      updatePoseButtons(motionKey);
      
      // Èùû„É´„Éº„Éó„ÅÆÂ†¥Âêà„ÄÅÁµÇ‰∫ÜÂæå„Å´„Çπ„É†„Éº„Ç∫„Å´Á´ã„Å°Âßø„Å´Êàª„Çã
      if (!loop) {
        // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÁµÇ‰∫Ü„ÇíÁõ£Ë¶ñ
        const onFinished = (event) => {
          if (event.action === newAction) {
            console.log('üé¨ VRMAÂÜçÁîüÁµÇ‰∫Ü„ÄÅ„Ç¢„Ç§„Éâ„É´„Å´Êàª„Çã');
            vrmaMixer.removeEventListener('finished', onFinished);
            // „Çπ„É†„Éº„Ç∫„Å´Á´ã„Å°Âßø„Å´Êàª„Çã
            setTimeout(() => {
              if (currentAction === newAction) {
                setPose('standing');
              }
            }, 100);
          }
        };
        vrmaMixer.addEventListener('finished', onFinished);
      }
    }

    // VRMA„ÅÆhumanoidTracks„Åã„ÇâAnimationClip„Çí‰ΩúÊàêÔºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÁî®Ôºâ
    function createClipFromVRMA(vrma) {
      const tracks = [];
      const humanoidTracks = vrma.humanoidTracks;
      
      // ÂêÑ„Éú„Éº„É≥„ÅÆ„Éà„É©„ÉÉ„ÇØ„ÇíÂá¶ÁêÜ
      for (const [boneName, trackData] of Object.entries(humanoidTracks)) {
        const boneNode = vrm.humanoid.getNormalizedBoneNode(boneName);
        if (!boneNode) continue;

        // ‰ΩçÁΩÆ„Éà„É©„ÉÉ„ÇØ
        if (trackData.position) {
          const posTrack = new THREE.VectorKeyframeTrack(
            boneNode.name + '.position',
            trackData.position.times,
            trackData.position.values
          );
          tracks.push(posTrack);
        }

        // ÂõûËª¢„Éà„É©„ÉÉ„ÇØ
        if (trackData.rotation) {
          const rotTrack = new THREE.QuaternionKeyframeTrack(
            boneNode.name + '.quaternion',
            trackData.rotation.times,
            trackData.rotation.values
          );
          tracks.push(rotTrack);
        }
      }

      const clip = new THREE.AnimationClip('VRMA', vrma.duration, tracks);
      return clip;
    }

    // ==================== „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„É´„Éº„Éó ====================
    function animate() {
      requestAnimationFrame(animate);
      
      const delta = clock.getDelta();
      const time = clock.getElapsedTime();
      
      if (vrm) {
        // VRMA„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Êõ¥Êñ∞
        if (vrmaMixer) {
          vrmaMixer.update(delta);
        }

        // „Ç¢„Ç§„Éâ„É´„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Êõ¥Êñ∞ÔºàVRMA„Åå„Å™„ÅÑÂ†¥Âêà„ÅÆ„ÅøÔºâ
        if (!currentVRMA || currentVRMA === 'standing') {
          updateIdleAnimation(delta, time);
        }
        
        // „É™„Ç¢„É´„Çø„Ç§„É†„É™„ÉÉ„Éó„Ç∑„É≥„ÇØÔºàÈü≥Â£∞ÂÜçÁîü‰∏≠Ôºâ
        if (isSpeaking && analyser && currentAudio) {
          updateRealtimeLipsync();
        }
        
        // Âè£„ÅÆÈñãÈñâ„Çπ„É†„Éº„Ç∏„É≥„Ç∞
        mouthOpenness += (targetMouthOpenness - mouthOpenness) * 0.3;
        applyMouthOpenness(mouthOpenness);
        
        // VRMÊõ¥Êñ∞
        vrm.update(delta);
      }
      
      renderer.render(scene, camera);
    }
    
    // ==================== „Ç¢„Ç§„Éâ„É´„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ ====================
    function updateIdleAnimation(delta, time) {
      if (!vrm) return;
      
      const config = IDLE_POSE_CONFIG;
      
      // --- „Éú„Éº„É≥„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÔºàJSONË®≠ÂÆö„Åã„ÇâÔºâ---
      for (const [boneName, boneConfig] of Object.entries(config.bones)) {
        const bone = vrm.humanoid.getNormalizedBoneNode(boneName);
        if (!bone) continue;
        
        // ÈùôÁöÑ„Å™ÂõûËª¢„ÇíÈÅ©Áî®
        if (boneConfig.rotation) {
          if (boneConfig.rotation.x !== undefined) bone.rotation.x = boneConfig.rotation.x;
          if (boneConfig.rotation.y !== undefined) bone.rotation.y = boneConfig.rotation.y;
          if (boneConfig.rotation.z !== undefined) bone.rotation.z = boneConfig.rotation.z;
        }
        
        // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„ÇíÈÅ©Áî®
        if (boneConfig.animation) {
          for (const [axis, animConfig] of Object.entries(boneConfig.animation)) {
            if (animConfig.type === 'breath') {
              // ÂëºÂê∏„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
              const phase = time * animConfig.frequency;
              bone.rotation[axis] = Math.sin(phase) * animConfig.amplitude;
            } else if (animConfig.type === 'headTilt') {
              // È†≠„ÅÆÂÇæ„ÅçÔºà„É©„É≥„ÉÄ„É†Ôºâ
              bone.rotation[axis] = idleState.headTilt;
            } else if (animConfig.amplitude !== undefined) {
              // ÈÄöÂ∏∏„ÅÆsinÊ≥¢„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥
              const phase = time * animConfig.frequency;
              const baseValue = animConfig.offset !== undefined ? animConfig.offset : 0;
              bone.rotation[axis] = baseValue + Math.sin(phase) * animConfig.amplitude;
            }
          }
        }
      }

      // --- Áû¨„ÅçÔºàJSONË®≠ÂÆö„Åã„ÇâÔºâ---
      const blinkConfig = config.expressions.blink;
      idleState.blinkTimer += delta;
      
      if (!idleState.isBlinking && idleState.blinkTimer >= idleState.nextBlink) {
        idleState.isBlinking = true;
        idleState.blinkTimer = 0;
      }
      
      if (idleState.isBlinking) {
        const blinkProgress = idleState.blinkTimer / blinkConfig.duration;
        if (blinkProgress < 1) {
          const blinkValue = Math.sin(blinkProgress * Math.PI);
          vrm.expressionManager.setValue('blink', blinkValue);
        } else {
          idleState.isBlinking = false;
          idleState.blinkTimer = 0;
          idleState.nextBlink = blinkConfig.interval.min + Math.random() * (blinkConfig.interval.max - blinkConfig.interval.min);
          vrm.expressionManager.setValue('blink', 0);
        }
      }
      
      // --- Ë¶ñÁ∑ö„ÅÆÂãï„Åç ---
      idleState.eyeLookAround.x += (idleState.eyeLookAround.targetX - idleState.eyeLookAround.x) * 0.02;
      idleState.eyeLookAround.y += (idleState.eyeLookAround.targetY - idleState.eyeLookAround.y) * 0.02;
      
      if (Math.random() < 0.005) {
        idleState.eyeLookAround.targetX = (Math.random() - 0.5) * 0.3;
        idleState.eyeLookAround.targetY = (Math.random() - 0.5) * 0.2;
      }
      
      // È†≠„ÅÆÂÇæ„Åç„ÇíÂ§â„Åà„Çã
      if (Math.random() < 0.002) {
        idleState.targetHeadTilt = (Math.random() - 0.5) * 0.1;
      }
      idleState.headTilt += (idleState.targetHeadTilt - idleState.headTilt) * 0.01;
    }

    // ==================== „Éù„Éº„Ç∫„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÔºàÊâãÊõ∏„ÅçÁî® - ÁèæÂú®„ÅØ‰ΩøÁî®„Åó„Å™„ÅÑÔºâ====================
    function updatePoseAnimation(delta, time) {
      // VRMA„Çí‰ΩøÁî®„Åô„Çã„Åü„ÇÅ„ÄÅ„Åì„ÅÆÈñ¢Êï∞„ÅØÁèæÂú®ÁÑ°ÂäπÂåñ
      // ÂøÖË¶Å„Å´Âøú„Åò„Å¶ÊâãÊõ∏„Åç„Éù„Éº„Ç∫Áî®„Å´Âæ©Ê¥ªÂèØËÉΩ
    }

    // Ë£úÈñìÈñ¢Êï∞
    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    function easeInOutCubic(t) {
      return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    // ==================== „Éù„Éº„Ç∫Â§âÊõ¥ÔºàVRMA‰ΩøÁî®Ôºâ====================
    function setPose(poseName) {
      // standing„ÅÆÂ†¥Âêà„ÅØVRMA„ÇíÂÅúÊ≠¢„Åó„Å¶„Ç¢„Ç§„Éâ„É´„Å´Êàª„Åô
      if (poseName === 'standing') {
        if (currentAction) {
          currentAction.fadeOut(0.5);
          currentAction = null;
        }
        currentVRMA = null;
        currentPose = 'standing';
        updatePoseButtons('standing');
        console.log('üßç „Ç¢„Ç§„Éâ„É´„Éù„Éº„Ç∫„Å´Êàª„Åô');
        return;
      }

      // VRMA„ÇíÂÜçÁîüÔºàÈùû„É´„Éº„Éó„ÄÅ„ÇØ„É≠„Çπ„Éï„Çß„Éº„Éâ‰ªò„ÅçÔºâ
      if (loadedVRMAs[poseName]) {
        playVRMA(poseName, false, 0.5);
      } else {
        console.warn('VRMA„ÅåË™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì:', poseName);
      }
    }

    // ==================== „Éá„Éê„ÉÉ„Ç∞„Éë„Éç„É´ÂãïÁöÑÁîüÊàê ====================
    function generateDebugPanel() {
      // „Çø„ÉñÂàá„ÇäÊõø„ÅàÊ©üËÉΩ
      const tabs = document.querySelectorAll('.control-tab');
      const contents = document.querySelectorAll('.control-content');

      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          const targetTab = tab.dataset.tab;

          // „Çø„Éñ„ÅÆ„Ç¢„ÇØ„ÉÜ„Ç£„ÉñÁä∂ÊÖãÂàá„ÇäÊõø„Åà
          tabs.forEach(t => t.classList.remove('active'));
          tab.classList.add('active');

          // „Ç≥„É≥„ÉÜ„É≥„ÉÑ„ÅÆË°®Á§∫Âàá„ÇäÊõø„Åà
          contents.forEach(content => {
            content.classList.remove('active');
            if (content.id === `${targetTab}-content`) {
              content.classList.add('active');
            }
          });
        });
      });

      // Ë°®ÊÉÖ„Éú„Çø„É≥„ÇíÁîüÊàê
      const expressionControls = document.getElementById('expression-controls');
      if (expressionControls) {
        expressionControls.innerHTML = '';
        const expressions = serverConfig.expressions?.available || ['neutral', 'happy', 'sad', 'angry', 'relaxed', 'surprised'];
        const expressionLabels = {
          neutral: 'ÊôÆÈÄö',
          happy: 'Â¨â„Åó„ÅÑ',
          sad: 'ÊÇ≤„Åó„ÅÑ',
          angry: 'ÊÄí„Çä',
          relaxed: '„É™„É©„ÉÉ„ÇØ„Çπ',
          surprised: 'È©ö„Åç'
        };

        expressions.forEach((expr, index) => {
          const btn = document.createElement('button');
          btn.className = `expr-btn ${expr}${index === 0 ? ' active' : ''}`;
          btn.dataset.expression = expr;
          btn.textContent = expressionLabels[expr] || expr;
          btn.addEventListener('click', () => {
            setExpression(expr);
            document.querySelectorAll('.expr-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
          });
          expressionControls.appendChild(btn);
        });
      }

      // VRMA„Éú„Çø„É≥„ÇíÁîüÊàêÔºàË™≠„ÅøËæº„ÇÅ„Åü„ÇÇ„ÅÆ„ÅÆ„ÅøÔºâ
      const poseControls = document.getElementById('pose-controls');
      if (poseControls) {
        poseControls.innerHTML = '';

        // standing„ÇíÊúÄÂàù„Å´ËøΩÂä†
        const poses = ['standing', ...Object.keys(loadedVRMAs)];

        poses.forEach((pose, index) => {
          const btn = document.createElement('button');
          btn.className = `pose-btn${index === 0 ? ' active' : ''}`;
          btn.dataset.pose = pose;
          btn.textContent = vrmaMotions[pose]?.name || pose;
          btn.addEventListener('click', () => {
            setPose(pose);
            updatePoseButtons(pose);
          });
          poseControls.appendChild(btn);
        });
      }

      // VRMAË™≠„ÅøËæº„ÅøÂÆå‰∫ÜÂæå„Å´„Éú„Çø„É≥„ÇíÊõ¥Êñ∞„Åô„ÇãÈñ¢Êï∞
      function refreshVRMAButtons() {
        if (!poseControls) return;
        poseControls.innerHTML = '';

        const poses = ['standing', ...Object.keys(loadedVRMAs)];
        poses.forEach((pose, index) => {
          const btn = document.createElement('button');
          btn.className = `pose-btn${index === 0 ? ' active' : ''}`;
          btn.dataset.pose = pose;
          btn.textContent = vrmaMotions[pose]?.name || pose;
          btn.addEventListener('click', () => {
            setPose(pose);
            updatePoseButtons(pose);
          });
          poseControls.appendChild(btn);
        });
      }

      // „Ç∞„É≠„Éº„Éê„É´„Å´ÂÖ¨Èñã„Åó„Å¶VRMAË™≠„ÅøËæº„ÅøÂÆå‰∫ÜÂæå„Å´Âëº„Åπ„Çã„Çà„ÅÜ„Å´„Åô„Çã
      window.refreshVRMAButtons = refreshVRMAButtons;

      // „Çπ„Éî„Éº„ÇØÂÖ•Âäõ„ÅÆ„Ç§„Éô„É≥„ÉàË®≠ÂÆö
      const speakInput = document.getElementById('speak-input');
      if (speakInput) {
        // Êó¢Â≠ò„ÅÆ„É™„Çπ„Éä„Éº„ÇíÂâäÈô§ÔºàÈáçË§áÈò≤Ê≠¢Ôºâ
        const newInput = speakInput.cloneNode(true);
        speakInput.parentNode.replaceChild(newInput, speakInput);

        newInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && newInput.value.trim()) {
            const text = newInput.value.trim();
            console.log('üó£Ô∏è Speak:', text);
            speak(text);
            newInput.value = '';
          }
        });
      }
    }

    // „Éù„Éº„Ç∫„Éú„Çø„É≥„ÅÆ„Ç¢„ÇØ„ÉÜ„Ç£„ÉñÁä∂ÊÖãÊõ¥Êñ∞
    function updatePoseButtons(activePose) {
      document.querySelectorAll('.pose-btn').forEach(btn => {
        if (btn.dataset.pose === activePose) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });
    }

    // ==================== „Éù„Éº„Ç∫„Éú„Çø„É≥Ë®≠ÂÆö ====================
    function setupPoseButtons() {
      // „Éá„Éê„ÉÉ„Ç∞„Éë„Éç„É´„ÅåÂãïÁöÑÁîüÊàê„Åï„Çå„Çã„Åü„ÇÅ„ÄÅ„Åì„ÅÆÈñ¢Êï∞„ÅØÂè§„ÅÑÂΩ¢ÂºèÁî®„Å´ÊÆã„Åô
      // ÁèæÂú®„ÅØ generateDebugPanel() „Åß„Éú„Çø„É≥„ÇíÁîüÊàê„Åó„Å¶„ÅÑ„Çã
    }

    // ==================== Ë®≠ÂÆö„Éë„Éç„É´ÂàùÊúüÂåñ ====================
    function initSettingsPanel() {
      // Ê≠ØËªä„Ç¢„Ç§„Ç≥„É≥„ÇØ„É™„ÉÉ„ÇØ„Åß„Éë„Éç„É´„ÇíÈñãÈñâ
      const settingsToggle = document.getElementById('settings-toggle');
      const settingsPanel = document.getElementById('settings-panel');
      let isPanelVisible = false;

      settingsToggle?.addEventListener('click', (e) => {
        e.stopPropagation();
        isPanelVisible = !isPanelVisible;
        settingsPanel.classList.toggle('visible', isPanelVisible);
      });

      // „Éë„Éç„É´Â§ñ„ÇØ„É™„ÉÉ„ÇØ„ÅßÈñâ„Åò„Çã
      document.addEventListener('click', (e) => {
        if (isPanelVisible && !settingsPanel.contains(e.target) && e.target !== settingsToggle) {
          isPanelVisible = false;
          settingsPanel.classList.remove('visible');
        }
      });

      // „Ç´„É°„É©Ë®≠ÂÆö
      const setupSlider = (id, settingKey, callback) => {
        const slider = document.getElementById(id);
        const valueDisplay = document.getElementById(id + '-value');
        slider?.addEventListener('input', (e) => {
          const value = parseFloat(e.target.value);
          cameraSettings[settingKey] = value;
          valueDisplay.textContent = value.toFixed(1);
          callback?.(value);
        });
      };

      setupSlider('camera-distance', 'distance', (value) => {
        camera.position.set(0, cameraSettings.height, value);
        camera.lookAt(0, cameraSettings.height, 0);
      });

      setupSlider('camera-height', 'height', (value) => {
        camera.position.set(0, value, cameraSettings.distance);
        camera.lookAt(0, value, 0);
      });

      setupSlider('camera-angle-x', 'angleX', (value) => {
        camera.position.x = value;
        camera.lookAt(0, cameraSettings.height, 0);
      });

      setupSlider('camera-fov', 'fov', (value) => {
        camera.fov = value;
        camera.updateProjectionMatrix();
      });

      // ËÉåÊôØ„Éó„É™„Çª„ÉÉ„Éà
      const bgPreset = document.getElementById('bg-preset');
      bgPreset?.addEventListener('change', (e) => {
        const preset = e.target.value;
        if (backgroundPresets[preset]) {
          document.body.style.background = backgroundPresets[preset];
          // Transparent mode: alpha: true in renderer
          if (preset === 'transparent') {
            // Already handled by renderer alpha setting
          }
        }
      });

      // „É©„Ç§„ÉàË®≠ÂÆö
      const mainLightSlider = document.getElementById('light-main');
      const mainLightValue = document.getElementById('light-main-value');
      mainLightSlider?.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        if (directionalLight) directionalLight.intensity = value;
        mainLightValue.textContent = value.toFixed(1);
      });

      const ambientLightSlider = document.getElementById('light-ambient');
      const ambientLightValue = document.getElementById('light-ambient-value');
      ambientLightSlider?.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        if (ambientLight) ambientLight.intensity = value;
        ambientLightValue.textContent = value.toFixed(1);
      });
    }

    // ==================== „ÇØ„É™„Ç®„Ç§„Ç∑„Éß„É≥„É¢„Éº„ÉâÂàùÊúüÂåñ ====================
    function initCreationMode() {
      console.log('üé® Initializing Creation Mode');

      // „Çø„ÉñÂàá„ÇäÊõø„Åà
      const tabs = document.querySelectorAll('.creation-tab');
      const contents = document.querySelectorAll('.creation-content');

      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          tabs.forEach(t => t.classList.remove('active'));
          contents.forEach(c => c.classList.remove('active'));
          tab.classList.add('active');
          document.getElementById(tab.dataset.tab + '-content').classList.add('active');
        });
      });

      // Ë°®ÊÉÖ„Çπ„É©„Ç§„ÉÄ„ÉºÁîüÊàê
      initExpressionSliders();

      // „Éú„Éº„É≥„É™„Çπ„ÉàÁîüÊàê
      initBoneList();

      // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„ÉºË®≠ÂÆö
      setupCreationModeEvents();

      // „É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏„Åã„Çâ„Éó„É™„Çª„ÉÉ„ÉàË™≠„ÅøËæº„Åø
      loadCustomPresets();
    }

    // Ë°®ÊÉÖ„Çπ„É©„Ç§„ÉÄ„ÉºÂàùÊúüÂåñ
    function initExpressionSliders() {
      const container = document.getElementById('expression-sliders');
      if (!vrm?.expressionManager || !container) return;

      container.innerHTML = '';

      // ÂÖ®„Å¶„ÅÆË°®ÊÉÖ„ÇíÂèñÂæó
      const expressions = vrm.expressionManager.expressions || [];
      console.log('üìã Available expressions:', expressions.map(e => e.expressionName));

      expressions.forEach(expr => {
        const sliderContainer = document.createElement('div');
        sliderContainer.className = 'expression-slider';

        const label = document.createElement('label');
        label.innerHTML = `<span>${expr.expressionName}</span><span id="value-${expr.expressionName}">0%</span>`;

        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = '0';
        slider.max = '1';
        slider.step = '0.01';
        slider.value = '0';
        slider.dataset.expressionName = expr.expressionName;

        slider.addEventListener('input', (e) => {
          const value = parseFloat(e.target.value);
          vrm.expressionManager.setValue(expr.expressionName, value);
          document.getElementById(`value-${expr.expressionName}`).textContent = Math.round(value * 100) + '%';
        });

        sliderContainer.appendChild(label);
        sliderContainer.appendChild(slider);
        container.appendChild(sliderContainer);
      });
    }

    // „Éú„Éº„É≥„É™„Çπ„ÉàÂàùÊúüÂåñ
    function initBoneList() {
      const container = document.getElementById('bone-list');
      if (!vrm?.humanoid || !container) return;

      container.innerHTML = '';

      // ‰∏ªË¶Å„Å™„Éú„Éº„É≥„ÅÆ„Åø„Çí„É™„Çπ„Éà„Ç¢„ÉÉ„Éó
      const boneNames = [
        'hips', 'spine', 'chest', 'upperChest', 'neck', 'head',
        'leftShoulder', 'leftUpperArm', 'leftLowerArm', 'leftHand',
        'rightShoulder', 'rightUpperArm', 'rightLowerArm', 'rightHand',
        'leftUpperLeg', 'leftLowerLeg', 'leftFoot',
        'rightUpperLeg', 'rightLowerLeg', 'rightFoot'
      ];

      boneNames.forEach(boneName => {
        const boneNode = vrm.humanoid.getNormalizedBoneNode(boneName);
        if (!boneNode) return;

        const boneItem = document.createElement('div');
        boneItem.className = 'bone-item';
        boneItem.dataset.boneName = boneName;
        boneItem.innerHTML = `<span class="bone-name">${boneName}</span>`;

        boneItem.addEventListener('click', () => selectBone(boneName));
        container.appendChild(boneItem);
      });
    }

    // „Éú„Éº„É≥ÈÅ∏Êäû
    function selectBone(boneName) {
      const boneNode = vrm.humanoid.getNormalizedBoneNode(boneName);
      if (!boneNode) return;

      selectedBone = boneName;

      // UIÊõ¥Êñ∞
      document.querySelectorAll('.bone-item').forEach(item => {
        item.classList.toggle('selected', item.dataset.boneName === boneName);
      });

      // ÂõûËª¢„Ç≥„É≥„Éà„É≠„Éº„É´Ë°®Á§∫
      const controls = document.getElementById('rotation-controls');
      controls.style.display = 'block';
      document.getElementById('selected-bone-name').textContent = boneName;

      // ÁèæÂú®„ÅÆÂõûËª¢ÂÄ§„ÇíÂèñÂæó
      const euler = new THREE.Euler().setFromQuaternion(boneNode.quaternion);
      document.getElementById('rotation-x').value = THREE.MathUtils.radToDeg(euler.x);
      document.getElementById('rotation-y').value = THREE.MathUtils.radToDeg(euler.y);
      document.getElementById('rotation-z').value = THREE.MathUtils.radToDeg(euler.z);

      updateRotationValues();
    }

    // ÂõûËª¢ÂÄ§Êõ¥Êñ∞
    function updateRotationValues() {
      document.getElementById('rotation-x-value').textContent = document.getElementById('rotation-x').value + '¬∞';
      document.getElementById('rotation-y-value').textContent = document.getElementById('rotation-y').value + '¬∞';
      document.getElementById('rotation-z-value').textContent = document.getElementById('rotation-z').value + '¬∞';
    }

    // „Éú„Éº„É≥ÂõûËª¢ÈÅ©Áî®
    function applyBoneRotation() {
      if (!selectedBone) return;

      const boneNode = vrm.humanoid.getNormalizedBoneNode(selectedBone);
      if (!boneNode) return;

      const x = THREE.MathUtils.degToRad(parseFloat(document.getElementById('rotation-x').value));
      const y = THREE.MathUtils.degToRad(parseFloat(document.getElementById('rotation-y').value));
      const z = THREE.MathUtils.degToRad(parseFloat(document.getElementById('rotation-z').value));

      const euler = new THREE.Euler(x, y, z);
      boneNode.quaternion.setFromEuler(euler);

      // ÂõûËª¢ÂÄ§„Çí‰øùÂ≠ò
      boneRotations[selectedBone] = { x, y, z };
    }

    // „ÇØ„É™„Ç®„Ç§„Ç∑„Éß„É≥„É¢„Éº„Éâ„ÅÆ„Ç§„Éô„É≥„ÉàË®≠ÂÆö
    function setupCreationModeEvents() {
      // Ë°®ÊÉÖ„Éó„É™„Çª„ÉÉ„Éà‰øùÂ≠ò
      document.getElementById('save-expression-btn')?.addEventListener('click', () => {
        const name = document.getElementById('new-expression-name').value.trim();
        if (!name) {
          alert('Please enter a preset name');
          return;
        }

        const expressionData = {};
        vrm.expressionManager.expressions.forEach(expr => {
          expressionData[expr.expressionName] = vrm.expressionManager.getValue(expr.expressionName);
        });

        customExpressions[name] = expressionData;
        saveCustomPresets();
        renderExpressionPresets();
        document.getElementById('new-expression-name').value = '';
        console.log('üíæ Expression saved:', name, expressionData);
      });

      // „Éù„Éº„Ç∫„Éó„É™„Çª„ÉÉ„Éà‰øùÂ≠ò
      document.getElementById('save-pose-btn')?.addEventListener('click', () => {
        const name = document.getElementById('new-pose-name').value.trim();
        if (!name) {
          alert('Please enter a pose name');
          return;
        }

        const poseData = {};
        vrm.humanoid.humanBones.forEach(bone => {
          const boneNode = vrm.humanoid.getNormalizedBoneNode(bone.name);
          if (boneNode) {
            const euler = new THREE.Euler().setFromQuaternion(boneNode.quaternion);
            poseData[bone.name] = {
              x: THREE.MathUtils.radToDeg(euler.x),
              y: THREE.MathUtils.radToDeg(euler.y),
              z: THREE.MathUtils.radToDeg(euler.z)
            };
          }
        });

        customPoses[name] = poseData;
        saveCustomPresets();
        renderPosePresets();
        document.getElementById('new-pose-name').value = '';
        console.log('üíæ Pose saved:', name);
      });

      // ÂõûËª¢„Çπ„É©„Ç§„ÉÄ„Éº
      ['x', 'y', 'z'].forEach(axis => {
        document.getElementById(`rotation-${axis}`)?.addEventListener('input', () => {
          applyBoneRotation();
          updateRotationValues();
        });
      });

      // „Éú„Éº„É≥„É™„Çª„ÉÉ„Éà
      document.getElementById('reset-bone-btn')?.addEventListener('click', () => {
        if (!selectedBone) return;
        const boneNode = vrm.humanoid.getNormalizedBoneNode(selectedBone);
        if (boneNode) {
          boneNode.quaternion.set(0, 0, 0, 1);
          document.getElementById('rotation-x').value = 0;
          document.getElementById('rotation-y').value = 0;
          document.getElementById('rotation-z').value = 0;
          applyBoneRotation();
          updateRotationValues();
        }
      });

      // ÂÖ®„Éú„Éº„É≥„É™„Çª„ÉÉ„Éà
      document.getElementById('reset-all-bones-btn')?.addEventListener('click', () => {
        vrm.humanoid.humanBones.forEach(bone => {
          const boneNode = vrm.humanoid.getNormalizedBoneNode(bone.name);
          if (boneNode) {
            boneNode.quaternion.set(0, 0, 0, 1);
          }
        });
        boneRotations = {};
        if (selectedBone) {
          selectBone(selectedBone);
        }
      });

      // „Ç®„ÇØ„Çπ„Éù„Éº„Éà/„Ç§„É≥„Éù„Éº„Éà
      document.getElementById('export-expressions-btn')?.addEventListener('click', () => exportModal('expressions'));
      document.getElementById('import-expressions-btn')?.addEventListener('click', () => importPresets('expressions'));
      document.getElementById('export-poses-btn')?.addEventListener('click', () => exportModal('poses'));
      document.getElementById('import-poses-btn')?.addEventListener('click', () => importPresets('poses'));

      // „É¢„Éº„ÉÄ„É´
      document.getElementById('modal-close-btn')?.addEventListener('click', () => {
        document.getElementById('export-modal').classList.remove('active');
      });

      document.getElementById('modal-copy-btn')?.addEventListener('click', () => {
        const textarea = document.getElementById('modal-textarea');
        textarea.select();
        document.execCommand('copy');
        alert('Copied to clipboard!');
      });
    }

    // „Éó„É™„Çª„ÉÉ„Éà‰øùÂ≠òÔºà„É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏Ôºâ
    function saveCustomPresets() {
      localStorage.setItem('phantom-vrm-expressions', JSON.stringify(customExpressions));
      localStorage.setItem('phantom-vrm-poses', JSON.stringify(customPoses));
    }

    // „Éó„É™„Çª„ÉÉ„ÉàË™≠„ÅøËæº„ÅøÔºà„É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏Ôºâ
    function loadCustomPresets() {
      try {
        const savedExpr = localStorage.getItem('phantom-vrm-expressions');
        const savedPoses = localStorage.getItem('phantom-vrm-poses');

        if (savedExpr) customExpressions = JSON.parse(savedExpr);
        if (savedPoses) customPoses = JSON.parse(savedPoses);

        renderExpressionPresets();
        renderPosePresets();
      } catch (e) {
        console.error('Failed to load presets:', e);
      }
    }

    // Ë°®ÊÉÖ„Éó„É™„Çª„ÉÉ„ÉàÊèèÁîª
    function renderExpressionPresets() {
      const container = document.getElementById('expression-presets');
      if (!container) return;

      container.innerHTML = '';

      Object.entries(customExpressions).forEach(([name, data]) => {
        const item = document.createElement('div');
        item.className = 'preset-item';
        item.innerHTML = `
          <span class="preset-name">${name}</span>
          <div class="preset-actions">
            <button data-action="apply">Apply</button>
            <button data-action="delete">‚úï</button>
          </div>
        `;

        item.querySelector('[data-action="apply"]').addEventListener('click', () => {
          Object.entries(data).forEach(([exprName, value]) => {
            vrm.expressionManager.setValue(exprName, value);
            const slider = document.querySelector(`[data-expression-name="${exprName}"]`);
            const valueDisplay = document.getElementById(`value-${exprName}`);
            if (slider) slider.value = value;
            if (valueDisplay) valueDisplay.textContent = Math.round(value * 100) + '%';
          });
        });

        item.querySelector('[data-action="delete"]').addEventListener('click', () => {
          delete customExpressions[name];
          saveCustomPresets();
          renderExpressionPresets();
        });

        container.appendChild(item);
      });
    }

    // „Éù„Éº„Ç∫„Éó„É™„Çª„ÉÉ„ÉàÊèèÁîª
    function renderPosePresets() {
      const container = document.getElementById('pose-presets');
      if (!container) return;

      container.innerHTML = '';

      Object.entries(customPoses).forEach(([name, data]) => {
        const item = document.createElement('div');
        item.className = 'preset-item';
        item.innerHTML = `
          <span class="preset-name">${name}</span>
          <div class="preset-actions">
            <button data-action="apply">Apply</button>
            <button data-action="delete">‚úï</button>
          </div>
        `;

        item.querySelector('[data-action="apply"]').addEventListener('click', () => {
          Object.entries(data).forEach(([boneName, rotation]) => {
            const boneNode = vrm.humanoid.getNormalizedBoneNode(boneName);
            if (boneNode) {
              const euler = new THREE.Euler(
                THREE.MathUtils.degToRad(rotation.x),
                THREE.MathUtils.degToRad(rotation.y),
                THREE.MathUtils.degToRad(rotation.z)
              );
              boneNode.quaternion.setFromEuler(euler);
            }
          });
        });

        item.querySelector('[data-action="delete"]').addEventListener('click', () => {
          delete customPoses[name];
          saveCustomPresets();
          renderPosePresets();
        });

        container.appendChild(item);
      });
    }

    // „Ç®„ÇØ„Çπ„Éù„Éº„Éà„É¢„Éº„ÉÄ„É´Ë°®Á§∫
    function exportModal(type) {
      const modal = document.getElementById('export-modal');
      const textarea = document.getElementById('modal-textarea');
      const title = document.getElementById('modal-title');

      const data = type === 'expressions' ? customExpressions : customPoses;
      title.textContent = `Export ${type === 'expressions' ? 'Expressions' : 'Poses'}`;
      textarea.value = JSON.stringify(data, null, 2);
      modal.classList.add('active');
    }

    // „Éó„É™„Çª„ÉÉ„Éà„Ç§„É≥„Éù„Éº„Éà
    function importPresets(type) {
      const input = prompt('Paste JSON data:');
      if (!input) return;

      try {
        const data = JSON.parse(input);
        if (type === 'expressions') {
          customExpressions = { ...customExpressions, ...data };
          renderExpressionPresets();
        } else {
          customPoses = { ...customPoses, ...data };
          renderPosePresets();
        }
        saveCustomPresets();
        alert(`Imported ${Object.keys(data).length} ${type}`);
      } catch (e) {
        alert('Invalid JSON data');
      }
    }

    // ==================== „ÉÜ„É≠„ÉÉ„ÉóË°®Á§∫ ====================
    function showTelop(text, duration = 0) {
      const telop = document.getElementById('telop');
      if (!telop) return;

      telop.textContent = text;
      telop.classList.add('visible');

      if (duration > 0) {
        setTimeout(() => {
          hideTelop();
        }, duration);
      }
    }

    function hideTelop() {
      const telop = document.getElementById('telop');
      if (telop) {
        telop.classList.remove('visible');
      }
    }

    // ==================== „É™„Ç¢„É´„Çø„Ç§„É†„É™„ÉÉ„Éó„Ç∑„É≥„ÇØ ====================
    function updateRealtimeLipsync() {
      if (!analyser) return;
      
      const dataArray = new Uint8Array(analyser.frequencyBinCount);
      analyser.getByteFrequencyData(dataArray);
      
      // ‰ΩéÂë®Ê≥¢Êï∞Â∏ØÂüü„ÅÆÂπ≥Âùá„ÇíË®àÁÆóÔºàÂè£„ÅÆÈñãÈñâ„Å´Èñ¢ÈÄ£Ôºâ
      let sum = 0;
      const lowFreqRange = Math.floor(dataArray.length * 0.3); // ‰∏ã‰Ωç30%„Çí‰ΩøÁî®
      
      for (let i = 0; i < lowFreqRange; i++) {
        sum += dataArray[i];
      }
      
      const average = sum / lowFreqRange;
      
      // Èü≥Èáè„ÇíÂè£„ÅÆÈñãÈñâ„Å´„Éû„ÉÉ„Éî„É≥„Ç∞Ôºà0-255 ‚Üí 0-1Ôºâ
      // ÈñæÂÄ§„Å®„Çπ„Ç±„Éº„É´„ÇíË™øÊï¥
      const threshold = 30;
      const scale = 3.0;
      
      if (average > threshold) {
        targetMouthOpenness = Math.min(1, (average - threshold) / 255 * scale);
      } else {
        targetMouthOpenness *= 0.8; // Á∑©„ÇÑ„Åã„Å´Èñâ„Åò„Çã
      }
    }
    
    // ==================== Âè£„ÅÆÈñãÈñâ ====================
    function applyMouthOpenness(value) {
      if (!vrm || !vrm.expressionManager) return;
      
      // Áô∫Ë©±ÊôÇ„ÅÆËá™ÁÑ∂„Å™Âè£„ÅÆÂΩ¢
      // aa: Â§ß„Åç„ÅèÈñã„Åè, ih: ‰∏≠Á®ãÂ∫¶, ou: ‰∏∏„Åè
      vrm.expressionManager.setValue('aa', value * 0.7);
      vrm.expressionManager.setValue('ih', value * 0.25);
      vrm.expressionManager.setValue('ou', value * 0.15);
      
      // ÊôÇÈñì„Å´„Çà„ÇãÂ§âÂåñ„ÅßËá™ÁÑ∂„Å™Âè£„ÅÆÂΩ¢„Å´
      const time = clock.getElapsedTime();
      const variation = Math.sin(time * 15) * 0.1 * value;
      vrm.expressionManager.setValue('ee', Math.max(0, variation));
    }
    
    // ==================== Ë°®ÊÉÖË®≠ÂÆö ====================
    function setExpression(expression) {
      if (!vrm || !vrm.expressionManager) return;
      
      console.log('üòä Ë°®ÊÉÖÂ§âÊõ¥:', expression);
      
      // ÂÖ®Ë°®ÊÉÖ„É™„Çª„ÉÉ„ÉàÔºàÂè£Èñ¢ÈÄ£„ÅØÁ∂≠ÊåÅÔºâ
      const expressions = ['happy', 'sad', 'angry', 'relaxed', 'surprised', 'neutral'];
      expressions.forEach(exp => {
        vrm.expressionManager.setValue(exp, 0);
      });
      
      // Ë°®ÊÉÖ„Éû„ÉÉ„Éî„É≥„Ç∞
      const expressionMap = {
        'happy': 'happy',
        'sad': 'sad',
        'angry': 'angry',
        'relaxed': 'relaxed',
        'surprised': 'surprised',
        'neutral': null,
        'joy': 'happy',
        'sorrow': 'sad',
        'anger': 'angry',
        'calm': 'relaxed',
        'surprise': 'surprised',
        'fun': 'happy',
        'excited': 'happy'
      };
      
      const mappedExpression = expressionMap[expression.toLowerCase()];
      
      if (mappedExpression) {
        vrm.expressionManager.setValue(mappedExpression, 1);
        currentExpression = mappedExpression;
      } else {
        currentExpression = 'neutral';
      }
    }
    
    // ==================== „É°„ÉÉ„Çª„Éº„Ç∏Âèó‰ø° ====================
    async function startMessagePolling() {
      const clientId = 'phantom-vrm-client';
      
      setInterval(async () => {
        try {
          const response = await fetch(`/api/message?clientId=${clientId}`);
          const data = await response.json();
          
          if (data.messages && data.messages.length > 0) {
            for (const msg of data.messages) {
              handleMessage(msg);
            }
          }
        } catch (e) {
          console.error('„Éù„Éº„É™„É≥„Ç∞„Ç®„É©„Éº:', e);
        }
      }, 500);
    }
    
    // ==================== „É°„ÉÉ„Çª„Éº„Ç∏Âá¶ÁêÜ ====================
    function handleMessage(msg) {
      console.log('üì© „É°„ÉÉ„Çª„Éº„Ç∏Âèó‰ø°:', msg);

      // Ë°®ÊÉÖÂ§âÊõ¥
      if (msg.expression) {
        setExpression(msg.expression);
      }

      // „Éù„Éº„Ç∫Â§âÊõ¥
      if (msg.pose) {
        setPose(msg.pose);
      }

      // Áô∫Ë©±
      if (msg.text) {
        speak(msg.text);
      }

      // „Ç´„É°„É©Ë®≠ÂÆö
      if (msg.camera) {
        const settings = msg.camera;
        if (settings.distance !== undefined) {
          camera.position.z = settings.distance;
        }
        if (settings.height !== undefined) {
          camera.position.y = settings.height;
          camera.lookAt(0, settings.height, 0);
        }
        if (settings.angleX !== undefined) {
          camera.position.x = settings.angleX;
          camera.lookAt(0, cameraSettings.height, 0);
        }
        if (settings.fov !== undefined) {
          camera.fov = settings.fov;
          camera.updateProjectionMatrix();
        }
        console.log('üì∑ Camera updated:', settings);
      }

      // ËÉåÊôØË®≠ÂÆö
      if (msg.background) {
        const presets = {
          default: 'linear-gradient(135deg, #1a1a2e 0%, #16213e 100%)',
          black: '#000000',
          green: '#00ff00',
          blue: '#0000ff',
          white: '#ffffff',
          transparent: 'transparent'
        };
        if (presets[msg.background]) {
          document.body.style.background = presets[msg.background];
          console.log('üé® Background updated:', msg.background);
        }
      }

      // „É©„Ç§„ÉàË®≠ÂÆö
      if (msg.lighting) {
        const settings = msg.lighting;
        if (settings.main !== undefined && directionalLight) {
          directionalLight.intensity = settings.main;
        }
        if (settings.ambient !== undefined && ambientLight) {
          ambientLight.intensity = settings.ambient;
        }
        console.log('üí° Lighting updated:', settings);
      }
    }
    
    // ==================== Áô∫Ë©± ====================
    async function speak(text) {
      console.log('üó£Ô∏è Áô∫Ë©±ÈñãÂßã:', text);

      // Êó¢„Å´ÂÜçÁîü‰∏≠„Å™„ÇâÂÅúÊ≠¢
      if (currentAudio) {
        currentAudio.pause();
        currentAudio = null;
      }

      isSpeaking = true;

      // „ÉÜ„É≠„ÉÉ„ÉóË°®Á§∫
      showTelop(text);
      
      // „ÉÜ„Ç≠„Çπ„Éà„Åã„ÇâË°®ÊÉÖ„ÇíÊé®ÂÆö
      autoDetectExpression(text);
      
      try {
        const response = await fetch('/api/tts', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text })
        });
        
        const data = await response.json();
        
        if (data.audioUrl) {
          // ÂÆüÈöõ„ÅÆÈü≥Â£∞„Åå„ÅÇ„ÇãÂ†¥Âêà
          await playAudioWithLipsync(data.audioUrl, data.duration || text.length * 80);
        } else {
          // Áñë‰ºº„É™„ÉÉ„Éó„Ç∑„É≥„ÇØ
          await fakeLipsync(data.duration || estimateDuration(text));
        }
      } catch (e) {
        console.error('TTS„Ç®„É©„Éº:', e);
        await fakeLipsync(estimateDuration(text));
      }
      
      isSpeaking = false;

      // „ÉÜ„É≠„ÉÉ„ÉóÈùûË°®Á§∫ÔºàÂ∞ë„ÅóÈÅÖ„Çâ„Åõ„Å¶Ôºâ
      setTimeout(() => {
        hideTelop();
      }, 500);
    }
    
    // ==================== Èü≥Â£∞ÂÜçÁîü + „É™„ÉÉ„Éó„Ç∑„É≥„ÇØ ====================
    async function playAudioWithLipsync(url, estimatedDuration) {
      return new Promise((resolve) => {
        const audio = new Audio(url);
        currentAudio = audio;
        
        // Web Audio API„ÅßÈü≥Â£∞„ÇíÂàÜÊûê
        let source = null;
        
        audio.addEventListener('canplaythrough', async () => {
          try {
            // AudioContext„Ååsuspend„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØresume
            if (audioContext && audioContext.state === 'suspended') {
              console.log('üîä AudioContext„ÇíÊúâÂäπÂåñ‰∏≠...');
              await audioContext.resume();
              audioContextUnlocked = true;
            }
            
            // Êó¢„Å´„Åì„ÅÆaudio„Å´„ÇΩ„Éº„Çπ„ÅåÊé•Á∂ö„Åï„Çå„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            if (audioSourceMap.has(audio)) {
              source = audioSourceMap.get(audio);
            } else if (audioContext && analyser && !audioSourceMap.has(audio)) {
              // Êñ∞„Åó„ÅèÈü≥Â£∞„ÇΩ„Éº„Çπ„Çí„Ç¢„Éä„É©„Ç§„Ç∂„Éº„Å´Êé•Á∂ö
              try {
                source = audioContext.createMediaElementSource(audio);
                source.connect(analyser);
                analyser.connect(audioContext.destination);
                audioSourceMap.set(audio, source);
                console.log('üîä „Ç™„Éº„Éá„Ç£„Ç™„ÇΩ„Éº„ÇπÊé•Á∂öÂÆå‰∫Ü');
              } catch (e) {
                // Êó¢„Å´Êé•Á∂ö„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØ„Ç®„É©„Éº„Å´„Å™„Çã„ÅÆ„ÅßÁÑ°Ë¶ñ
                console.warn('Audio source connection warning:', e.message);
              }
            }
            
            console.log('üîä Èü≥Â£∞ÂÜçÁîüÈñãÂßã:', url);
            await audio.play();
          } catch (e) {
            console.warn('Audio play error:', e);
            // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „É™„ÉÉ„Éó„Ç∑„É≥„ÇØ„Å™„Åó„ÅßÂÜçÁîüË©¶Ë°å
            try {
              await audio.play();
            } catch (e2) {
              console.error('Fallback play also failed:', e2);
              resolve();
            }
          }
        });
        
        audio.addEventListener('ended', () => {
          console.log('üîä Èü≥Â£∞ÂÜçÁîüÁµÇ‰∫Ü');
          targetMouthOpenness = 0;
          speakEndTime = clock.getElapsedTime() + 0.5;
          currentAudio = null;
          resolve();
        });
        
        audio.addEventListener('error', (e) => {
          console.error('Èü≥Â£∞ÂÜçÁîü„Ç®„É©„Éº:', e);
          targetMouthOpenness = 0;
          currentAudio = null;
          resolve();
        });
        
        // „Çø„Ç§„É†„Ç¢„Ç¶„ÉàÔºàÂÆâÂÖ®Á≠ñÔºâ
        setTimeout(() => {
          if (currentAudio === audio) {
            console.log('üîä Èü≥Â£∞ÂÜçÁîü„Çø„Ç§„É†„Ç¢„Ç¶„Éà');
            targetMouthOpenness = 0;
            speakEndTime = clock.getElapsedTime() + 0.5;
            currentAudio = null;
            resolve();
          }
        }, estimatedDuration + 2000);
        
        // Ë™≠„ÅøËæº„ÅøÈñãÂßã
        audio.load();
      });
    }
    
    // ==================== Áñë‰ºº„É™„ÉÉ„Éó„Ç∑„É≥„ÇØ ====================
    async function fakeLipsync(durationMs) {
      return new Promise((resolve) => {
        const startTime = Date.now();
        
        const updateLips = () => {
          const elapsed = Date.now() - startTime;
          
          if (elapsed >= durationMs) {
            targetMouthOpenness = 0;
            speakEndTime = clock.getElapsedTime() + 0.5;
            resolve();
            return;
          }
          
          // Èü≥ÁØÄ„Åî„Å®„ÅÆÂè£„ÅÆÂãï„Åç„Çí„Ç∑„Éü„É•„É¨„Éº„Éà
          // Ë§áÊï∞„ÅÆÂë®Ê≥¢Êï∞„ÇíÁµÑ„ÅøÂêà„Çè„Åõ„Å¶Ëá™ÁÑ∂„Å™Âãï„Åç„Å´
          const t = elapsed / 1000;
          const base = 0.4;
          const variation1 = Math.sin(t * 12) * 0.25;
          const variation2 = Math.sin(t * 7) * 0.15;
          const variation3 = Math.sin(t * 18) * 0.1;
          
          targetMouthOpenness = Math.max(0, base + variation1 + variation2 + variation3);
          
          requestAnimationFrame(updateLips);
        };
        
        updateLips();
      });
    }
    
    // ==================== Áô∫Ë©±ÊôÇÈñìÊé®ÂÆö ====================
    function estimateDuration(text) {
      const charsPerSecond = 12;
      return (text.length / charsPerSecond) * 1000;
    }
    
    // ==================== „ÉÜ„Ç≠„Çπ„Éà„Åã„ÇâË°®ÊÉÖÊé®ÂÆö ====================
    function autoDetectExpression(text) {
      const patterns = {
        happy: /Â¨â„Åó|„ÇÑ„Å£„Åü|ÊúÄÈ´ò|Á¥†Êô¥„Çâ„Åó|„ÅÇ„Çä„Åå„Å®„ÅÜ|Â•Ω„Åç|Ê•Ω„Åó„ÅÑ|„Çè„Éº„ÅÑ|!\!|‚ô™|üéâ|üòÄ|üòÉ|üòÑ|‚ú®|üíï|‚ù§Ô∏è/,
        sad: /ÊÇ≤„Åó|Ëæõ„ÅÑ|Ê≥£|Ê∂ô|Âõ∞„Å£„Åü|üò¢|üò≠|üòû|üíî/,
        angry: /ÊÄí|Ë®±„Åï„Å™„ÅÑ|„ÇÄ„Åã„Å§„Åè|ÊúÄÊÇ™|ËÖπÁ´ã|üò†|üò°|üí¢|üî•/,
        surprised: /„Åà„Å£|„Åæ„Åï„Åã|Êú¨ÂΩì|„Åô„Åî„ÅÑ|„Å≥„Å£„Åè„Çä|üò≤|üòÆ|üò±|‚ÅâÔ∏è/,
        relaxed: /„É™„É©„ÉÉ„ÇØ„Çπ|„ÅÆ„Çì„Å≥„Çä|ËêΩ„Å°ÁùÄ„Åè|ÂÆâÂøÉ|üòå|üòä|üçµ/
      };
      
      for (const [expr, pattern] of Object.entries(patterns)) {
        if (pattern.test(text)) {
          setExpression(expr);
          return;
        }
      }
      // „Éá„Éï„Ç©„É´„Éà„ÅØÁèæÂú®„ÅÆË°®ÊÉÖ„ÇíÁ∂≠ÊåÅ
    }
    
    // ==================== „É™„Çµ„Ç§„Ç∫ ====================
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // ==================== ÈñãÂßã ====================
    init();
    
    // „Ç∞„É≠„Éº„Éê„É´APIÔºà„Éá„Éê„ÉÉ„Ç∞Áî®Ôºâ
    window.phantomVRM = {
      speak,
      setExpression,
      setPose,
      setMouthOpenness: (v) => { targetMouthOpenness = v; },
      showTelop,
      hideTelop,
      getVRM: () => vrm,
      getCurrentPose: () => currentPose,
      // „ÉÜ„Çπ„ÉàÁî®„É°„ÇΩ„ÉÉ„Éâ
      test: async () => {
        await speak('„Åì„Çì„Å´„Å°„ÅØÔºÅ„Ç¢„Éê„Çø„Éº„Åß„Åô„ÄÇ„Çà„Çç„Åó„Åè„Å≠ÔºÅ');
      },
      testExpression: () => {
        const exprs = ['happy', 'sad', 'angry', 'surprised', 'relaxed', 'neutral'];
        let i = 0;
        const next = () => {
          if (i < exprs.length) {
            setExpression(exprs[i]);
            console.log('Expression:', exprs[i]);
            i++;
            setTimeout(next, 2000);
          }
        };
        next();
      },
      testPoses: () => {
        const poseList = ['standing', 'showBody', 'greeting', 'vSign', 'shoot', 'spin', 'modelPose', 'squat'];
        let i = 0;
        const next = () => {
          if (i < poseList.length) {
            setPose(poseList[i]);
            console.log('Pose:', poseList[i]);
            i++;
            setTimeout(next, 4000);
          }
        };
        next();
      }
    };
  </script>
</body>
</html>
